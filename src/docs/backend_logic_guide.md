# Backend Logic & Gamification - Developer's Guide v1.0

**Objective:** This document serves as the technical blueprint for the backend logic required to power the dynamic features of the Dynamic Pi Wallet View application. It is the "source of truth" for any developer or AI agent tasked with building the backend services.

---

## 1. Core Principle: Decoupled Logic

The frontend UI components are designed to be "dumb." They receive data and display it. The complex business logic, calculations, and data mutations MUST be handled by the backend. The frontend makes simple, authenticated API calls (e.g., `getUserData`, `getTeamActivity`) and expects the backend to return a fully-formed data object matching the schemas in `src/data/schemas.ts`.

---

## 2. Dynamic Data & API Endpoints

### 2.1. Pi to USD Conversion

*   **Endpoint (Suggestion):** `GET /api/v1/pi-price`
*   **Logic:**
    1.  The backend service should integrate with a reliable cryptocurrency price oracle or exchange API (e.g., CoinGecko, Binance, or a Pi-specific source when available).
    2.  The service should fetch the current price of Pi in USD.
    3.  Implement caching (e.g., for 5-10 minutes) to avoid hitting the external API on every single user request.
*   **Frontend Expectation:** The `KPICard` for "Total Pi Balance" expects a `usdValue` field to be present in the user data it receives, which it can then display. The frontend will NOT perform the multiplication.

### 2.2. User & Team Data Aggregation

*   **Endpoint (Suggestion):** `GET /api/v1/dashboard-data`
*   **Logic:**
    1.  This endpoint should be the primary source of data for the main dashboard.
    2.  It needs to aggregate data from multiple sources:
        *   The user's core Pi Network data (balance, etc.).
        *   The user's team member list.
        *   The user's node performance data.
    3.  **Crucially, it must calculate and include the activity metrics:** `userActiveMiningHours_LastWeek`, `userActiveMiningHours_LastMonth`, `activeMiningDays_LastWeek`, `activeMiningDays_LastMonth`. This requires querying historical mining session data.
*   **Frontend Expectation:** The frontend expects a single, rich `User` object that contains all the pre-calculated metrics needed for the dashboard cards.

---

## 3. Gamification Engine (Badge Attribution)

This is a critical backend service that should run periodically (e.g., once every 24 hours) or be triggered by specific events.

*   **Engine Logic:** For each user, the gamification engine must:
    1.  Fetch the user's current badges and activity data.
    2.  Check the criteria for each **unearned** badge.
    3.  If criteria are met, update the user's profile to mark the badge as `earned: true` and set the `earnedDate`.
    4.  Trigger a new notification (see Section 4).

*   **Badge Criteria Definitions:**
    *   **`b_wmara` (Weekly Mining Marathoner):** `activeMiningDays_LastWeek` >= 7.
    *   **`b_mmded` (Monthly Mining Dedication):** `activeMiningDays_LastMonth` >= (number of days in the last calendar month).
    *   **`b_twtm` (Team's Weekly Top Miner):** User's `teamMemberActiveMiningHours_LastWeek` is the highest among all 'active' members of their team for the past week.
    *   **`b_tmmc` (Team's Monthly Mining Champion):** User's `teamMemberActiveMiningHours_LastMonth` is the highest for the past month.
    *   **`b_otp` (Outpaced the Pack):** User's weekly mining hours are >= 150% of the team's average weekly mining hours.
    *   **`b_atl` (Active Team Leader):** >= 75% of the user's team members have a `status` of 'active'.

---

## 4. Notification Service

The backend must generate notifications based on specific events.

*   **Endpoint (Suggestion):** `GET /api/v1/notifications`
*   **Trigger Events & Logic:**
    *   **`badge_earned`:** Generated by the Gamification Engine when a badge is awarded.
    *   **`team_update`:** Triggered when a team member's `kycStatus` changes to `completed`. The notification description should name the member.
    *   **`node_update`:** A periodic check compares the user's `nodeSoftwareVersion` with the `latestSoftwareVersion`. If they differ, a notification is generated.
    *   **`announcement`:** Can be manually triggered by an admin to send system-wide messages.
*   **Frontend Expectation:** The `NotificationsDropdown` in the header polls this endpoint to get a list of notifications, which it then displays.
